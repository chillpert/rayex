#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_ARB_shader_clock : enable

#include "Random.glsl"
#include "Ray.glsl"

layout( location = 0 ) rayPayloadEXT RayPayLoad ray;

layout( binding = 0, set = 0 ) uniform accelerationStructureEXT topLevelAS;
layout( binding = 1, set = 0, rgba32f ) uniform image2D image;

layout( binding = 0, set = 1 ) uniform CameraProperties
{
  mat4 view;
  mat4 proj;
  mat4 viewInverse;
  mat4 projInverse;
  vec4 position;
  vec4 viewingDirection;

  vec4 padding1;
  vec4 padding2;
}
cam;

layout( push_constant ) uniform Constants
{
  vec4 clearColor;
  int frameCount;
  uint sampleRatePerPixel;
  uint maxPathDepth;
  bool useEnvironmentMap;

  uint padding0;
  uint padding1;
  uint padding2;
  uint padding3;
};

void main( )
{
  uint seed      = tea( gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, int( clockARB( ) ) );
  vec3 hitValues = vec3( 0.0 );

  for ( uint i = 0; i < sampleRatePerPixel; ++i )
  {
    ray.seed = tea( gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, int( clockARB( ) ) );

    // Jitter position within pixel to get free AA.
    vec2 positionWithinPixel   = vec2( gl_LaunchIDEXT.xy ) + vec2( rnd( seed ), rnd( seed ) );
    const vec2 normalizedPixel = positionWithinPixel / vec2( gl_LaunchSizeEXT.xy );
    vec2 d                     = normalizedPixel * 2.0 - 1.0;

    vec4 origin    = cam.viewInverse * vec4( 0.0, 0.0, 0.0, 1.0 );
    vec4 target    = cam.projInverse * vec4( d.x, d.y, 1.0, 1.0 );
    vec4 direction = cam.viewInverse * vec4( normalize( target.xyz ), 0.0 );

    ray.direction  = direction.xyz;
    ray.origin     = origin.xyz;
    ray.weight     = vec3( 0.0 );
    ray.emission   = vec3( 0.0 );
    ray.reflective = false;
    ray.refractive = false;

    vec3 weight   = vec3( 1.0 );
    vec3 hitValue = vec3( 0.0 );

    uint rayFlags = gl_RayFlagsNoneEXT;
    float tMin    = 0.001;
    float tMax    = 10000.0;

    int refractionCounter = 0;

    for ( ray.depth = 0; ray.depth <= maxPathDepth; ++ray.depth )
    {
      // refractive rays are allowed to bounce more time to have the all effects at lower sample rates
      if ( ray.refractive )
      {
        ray.depth -= 1;
        ++refractionCounter;
      }

      if ( refractionCounter > 5 )
      {
        ray.depth = maxPathDepth + 1;
      }

      // Clear color overwrites black
      //if ( ray.depth >= maxPathDepth )
      //{
      //  hitValue += clearColor.xyz * weight;
      //  weight *= ray.weight;
      //}
      //else
      //{
      traceRayEXT( topLevelAS,    // acceleration structure
                   rayFlags,      // rayFlags
                   0xFF,          // cullMask
                   0,             // sbtRecordOffset
                   0,             // sbtRecordStride
                   0,             // missIndex
                   ray.origin,    // ray origin
                   tMin,          // ray min range
                   ray.direction, // ray direction
                   tMax,          // ray max range
                   0 );           // payload (location = 0)

      hitValue += ray.emission * weight;
      weight *= ray.weight;
      //}
    }

    hitValues += hitValue;
  }

  // weighted average
  vec3 color = hitValues / sampleRatePerPixel;

  // Interpolate results over time (length defined on host as frame count (int))
  // First frame
  if ( frameCount <= 0 )
  {
    vec4 finalColor = vec4( color, 1.0 );
    imageStore( image, ivec2( gl_LaunchIDEXT.xy ), finalColor );
  }
  // Following frames: linearly interpolate between previous and current color.
  else
  {
    vec3 oldColor   = imageLoad( image, ivec2( gl_LaunchIDEXT.xy ) ).xyz;
    vec4 finalColor = vec4( mix( oldColor, color, 1.0 / float( frameCount ) ), 1.0 );
    imageStore( image, ivec2( gl_LaunchIDEXT.xy ), finalColor );
  }
}
