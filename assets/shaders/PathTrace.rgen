#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_ARB_shader_clock : enable

#include "Random.glsl"
#include "Ray.glsl"

layout( location = 0 ) rayPayloadEXT hitPayload prd;

layout( binding = 0, set = 0 ) uniform accelerationStructureEXT topLevelAS;
layout( binding = 1, set = 0, rgba32f ) uniform image2D image;

layout( binding = 0, set = 1 ) uniform CameraProperties
{
  mat4 view;
  mat4 proj;
  mat4 viewInverse;
  mat4 projInverse;
  vec4 cameraPos;

  vec4 padding0;
  vec4 padding1;
  vec4 padding2;
}
cam;

layout( push_constant ) uniform Constants
{
  vec4 clearColor;
  uint frameCount;
  uint sampleRatePerPixel;
  uint maxRecursionDepth;
  uint directionalLightCount;
  uint pointLightCount;
  bool useEnvironmentMap;

  uint padding0;
  uint padding1;
};

void rayTrace( vec2 positionWithinPixel )
{
  const vec2 inUV = positionWithinPixel / vec2( gl_LaunchSizeEXT.xy );
  vec2 d          = inUV * 2.0 - 1.0;

  vec4 origin    = cam.viewInverse * vec4( 0, 0, 0, 1 );
  vec4 target    = cam.projInverse * vec4( d.x, d.y, 1, 1 );
  vec4 direction = cam.viewInverse * vec4( normalize( target.xyz ), 0 );

  prd.rayDirection = direction.xyz;
  prd.rayOrigin    = origin.xyz;
  prd.weight       = vec3( 0 );

  vec3 curWeight = vec3( 1 );
  vec3 hitValue  = vec3( 0 );

  uint rayFlags = gl_RayFlagsOpaqueEXT;
  float tMin    = 0.001;
  float tMax    = 10000.0;

  for ( ; prd.depth < maxRecursionDepth; prd.depth++ )
  {
    traceRayEXT( topLevelAS,       // acceleration structure
                 rayFlags,         // rayFlags
                 0xFF,             // cullMask
                 0,                // sbtRecordOffset
                 0,                // sbtRecordStride
                 0,                // missIndex
                 prd.rayOrigin,    // ray origin
                 tMin,             // ray min range
                 prd.rayDirection, // ray direction
                 tMax,             // ray max range
                 0 );              // payload (location = 0)

    hitValue += prd.hitValue * curWeight;
    curWeight *= prd.weight;
  }
}

void accumulateSamples( )
{
  // Do accumulation over time
  if ( frameCount > 0 )
  {
    float a        = 1.0f / float( frameCount + 1 );
    vec3 old_color = imageLoad( image, ivec2( gl_LaunchIDEXT.xy ) ).xyz;
    imageStore( image, ivec2( gl_LaunchIDEXT.xy ), vec4( mix( old_color, prd.hitValue, a ), 1.0f ) );
  }
  else
  {
    // First frame, replace the value in the buffer
    imageStore( image, ivec2( gl_LaunchIDEXT.xy ), vec4( prd.hitValue, 1.0f ) );
  }
}

void main( )
{
  uint seed      = tea( gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, frameCount );
  vec3 hitValues = vec3( 0.0 );

  for ( uint i = 0; i < sampleRatePerPixel; ++i )
  {
    prd.seed = tea( gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, int( clockARB( ) ) );

    vec2 positionWithinPixel = vec2( gl_LaunchIDEXT.xy ) + vec2( rnd( seed ), rnd( seed ) );
    const vec2 inUV          = positionWithinPixel / vec2( gl_LaunchSizeEXT.xy );
    vec2 d                   = inUV * 2.0 - 1.0;

    vec4 origin    = cam.viewInverse * vec4( 0, 0, 0, 1 );
    vec4 target    = cam.projInverse * vec4( d.x, d.y, 1, 1 );
    vec4 direction = cam.viewInverse * vec4( normalize( target.xyz ), 0 );

    prd.rayDirection = direction.xyz;
    prd.rayOrigin    = origin.xyz;
    prd.weight       = vec3( 0 );

    vec3 curWeight = vec3( 1 );
    vec3 hitValue  = vec3( 0 );

    uint rayFlags = gl_RayFlagsOpaqueEXT;
    float tMin    = 0.001;
    float tMax    = 10000.0;

    for ( prd.depth = 0; prd.depth < maxRecursionDepth; prd.depth++ )
    {
      traceRayEXT( topLevelAS,       // acceleration structure
                   rayFlags,         // rayFlags
                   0xFF,             // cullMask
                   0,                // sbtRecordOffset
                   0,                // sbtRecordStride
                   0,                // missIndex
                   prd.rayOrigin,    // ray origin
                   tMin,             // ray min range
                   prd.rayDirection, // ray direction
                   tMax,             // ray max range
                   0 );              // payload (location = 0)

      hitValue += prd.hitValue * curWeight;
      curWeight *= prd.weight;
    }

    hitValues += hitValue;

    // Do accumulation over time
    if ( frameCount > 0 )
    {
      float a        = 1.0f / float( frameCount + 1 );
      vec3 old_color = imageLoad( image, ivec2( gl_LaunchIDEXT.xy ) ).xyz;
      imageStore( image, ivec2( gl_LaunchIDEXT.xy ), vec4( mix( old_color, hitValue, a ), 1.0f ) );
    }
    else
    {
      // First frame, replace the value in the buffer
      imageStore( image, ivec2( gl_LaunchIDEXT.xy ), vec4( hitValue, 1.0f ) );
    }
  }

  prd.hitValue = hitValues / sampleRatePerPixel;

  // Do accumulation over time
  if ( frameCount > 0 )
  {
    float a        = 1.0f / float( frameCount + 1 );
    vec3 old_color = imageLoad( image, ivec2( gl_LaunchIDEXT.xy ) ).xyz;
    imageStore( image, ivec2( gl_LaunchIDEXT.xy ), vec4( mix( old_color, prd.hitValue, a ), 1.0f ) );
  }
  else
  {
    // First frame, replace the value in the buffer
    imageStore( image, ivec2( gl_LaunchIDEXT.xy ), vec4( prd.hitValue, 1.0f ) );
  }
}
