#version 460
#extension GL_EXT_ray_tracing : require

#include "random.glsl"
#include "raycommon.glsl"

layout( location = 0 ) rayPayloadEXT hitPayload prd;

layout( binding = 0, set = 0 ) uniform accelerationStructureEXT topLevelAS;
layout( binding = 1, set = 0, rgba32f ) uniform image2D image;

layout( binding = 0, set = 1 ) uniform CameraProperties
{
  mat4 view;
  mat4 proj;
  mat4 viewInverse;
  mat4 projInverse;
  vec3 cameraPos;
}
cam;

layout( push_constant ) uniform Constants
{
  vec4 clearColor;
  uint frameCount;
  uint jitterCamSampleRatePerRayGen;
  bool jitterCamEnabled;
};

void main( )
{
  float r1       = 0;
  float r2       = 0;
  vec3 hitValues = vec3( 0 );

  uint seed;
  if ( jitterCamEnabled )
  {
    // Initialize the random number
    seed = tea( gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, frameCount );
  }

  for ( uint i = 0; i < jitterCamSampleRatePerRayGen; ++i )
  {
    if ( jitterCamEnabled )
    {
      // Then we need two random numbers to vary the X and Y inside the pixel, except for frame 0, where we always shoot in the center.
      r1 = rnd( seed );
      r2 = rnd( seed );
    }

    // Subpixel jitter: send the ray through a different position inside the pixel
    // each time, to provide antialiasing.
    vec2 subpixel_jitter = frameCount == 0 ? vec2( 0.5, 0.5 ) : vec2( r1, r2 );

    vec2 pixelCenter;
    if ( jitterCamEnabled )
    {
      pixelCenter = vec2( gl_LaunchIDEXT.xy ) + subpixel_jitter;
    }
    else
    {
      pixelCenter = vec2( gl_LaunchIDEXT.xy ) + vec2( 0.5 );
    }

    const vec2 inUV = pixelCenter / vec2( gl_LaunchSizeEXT.xy );
    vec2 d          = inUV * 2.0 - 1.0;

    vec4 origin    = cam.viewInverse * vec4( 0, 0, 0, 1 );
    vec4 target    = cam.projInverse * vec4( d.x, d.y, 1, 1 );
    vec4 direction = cam.viewInverse * vec4( normalize( target.xyz ), 0 );

    uint rayFlags = gl_RayFlagsOpaqueEXT;
    float tMin    = 0.001;
    float tMax    = 10000.0;

    traceRayEXT( topLevelAS,    // acceleration structure
                 rayFlags,      // rayFlags
                 0xFF,          // cullMask
                 0,             // sbtRecordOffset
                 0,             // sbtRecordStride
                 0,             // missIndex
                 origin.xyz,    // ray origin
                 tMin,          // ray min range
                 direction.xyz, // ray direction
                 tMax,          // ray max range
                 0 );           // payload (location = 0)

    hitValues += prd.hitValue;
  }

  prd.hitValue = hitValues / jitterCamSampleRatePerRayGen;

  // Do accumulation over time
  if ( jitterCamEnabled && frameCount > 0 )
  {
    float a        = 1.0 / float( frameCount + 1 );
    vec3 old_color = imageLoad( image, ivec2( gl_LaunchIDEXT.xy ) ).xyz;
    imageStore( image, ivec2( gl_LaunchIDEXT.xy ), vec4( mix( old_color, prd.hitValue, a ), 1.0 ) );
  }
  else
  {
    // First frame, replace the value in the buffer
    imageStore( image, ivec2( gl_LaunchIDEXT.xy ), vec4( prd.hitValue, 1.0 ) );
  }
}
