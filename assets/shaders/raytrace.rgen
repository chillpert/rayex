#version 460
#extension GL_EXT_ray_tracing : require

#include "random.glsl"
#include "raycommon.glsl"

layout( location = 0 ) rayPayloadEXT hitPayload prd;

layout( binding = 0, set = 0 ) uniform accelerationStructureEXT topLevelAS;
layout( binding = 1, set = 0, rgba32f ) uniform image2D image;

layout( binding = 0, set = 1 ) uniform CameraProperties
{
  mat4 view;
  mat4 proj;
  mat4 viewInverse;
  mat4 projInverse;
  vec4 cameraPos;

  vec4 padding0;
  vec4 padding1;
  vec4 padding2;
}
cam;

layout( push_constant ) uniform Constants
{
  vec4 clearColor;
  uint frameCount;
  uint jitterCamSampleRatePerRayGen;
  uint ssaa;
  bool jitterCamEnabled;
  bool ssaaEnabled;

  uint directionalLightCount;
  uint pointLightCount;
  uint skyboxCubeGeometryIndex;
};

void rayTrace( vec2 positionWithinPixel )
{
  const vec2 inUV = positionWithinPixel / vec2( gl_LaunchSizeEXT.xy );
  vec2 d          = inUV * 2.0 - 1.0;

  vec4 origin    = cam.viewInverse * vec4( 0, 0, 0, 1 );
  vec4 target    = cam.projInverse * vec4( d.x, d.y, 1, 1 );
  vec4 direction = cam.viewInverse * vec4( normalize( target.xyz ), 0 );

  prd.rayDirection = direction;

  uint rayFlags = gl_RayFlagsOpaqueEXT;
  float tMin    = 0.001;
  float tMax    = 10000.0;

  traceRayEXT( topLevelAS,    // acceleration structure
               rayFlags,      // rayFlags
               0xFF,          // cullMask
               0,             // sbtRecordOffset
               0,             // sbtRecordStride
               0,             // missIndex
               origin.xyz,    // ray origin
               tMin,          // ray min range
               direction.xyz, // ray direction
               tMax,          // ray max range
               0 );           // payload (location = 0)
}

void main( )
{
  // Use SSAA
  if ( ssaaEnabled )
  {
    vec3 hitValues             = vec3( 0.0 );
    const float ssaaFloat      = float( ssaa );
    const float interval       = 1.0 / ssaaFloat;
    const float subPixelCenter = interval / 2.0;

    for ( float x = 0.0; x < 1.0; x += interval )
    {
      for ( float y = 0.0; y < 1.0; y += interval )
      {
        vec2 positionWithinPixel = vec2( gl_LaunchIDEXT.xy ) + vec2( x + subPixelCenter, y + subPixelCenter );
        rayTrace( positionWithinPixel );

        hitValues += prd.hitValue;
      }
    }

    prd.hitValue = hitValues / ( ssaaFloat * ssaaFloat );
    imageStore( image, ivec2( gl_LaunchIDEXT.xy ), vec4( prd.hitValue, 1.0 ) );
  }
  // Use jitter cam
  else if ( jitterCamEnabled )
  {
    uint seed      = tea( gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, frameCount );
    vec3 hitValues = vec3( 0.0 );

    for ( uint i = 0; i < jitterCamSampleRatePerRayGen; ++i )
    {
      vec2 positionWithinPixel = vec2( gl_LaunchIDEXT.xy ) + vec2( rnd( seed ), rnd( seed ) );
      rayTrace( positionWithinPixel );

      hitValues += prd.hitValue;
    }

    prd.hitValue = hitValues / jitterCamSampleRatePerRayGen;

    if ( frameCount > 0 )
    {
      float a        = 1.0 / float( frameCount + 1 );
      vec3 old_color = imageLoad( image, ivec2( gl_LaunchIDEXT.xy ) ).xyz;
      imageStore( image, ivec2( gl_LaunchIDEXT.xy ), vec4( mix( old_color, prd.hitValue, a ), 1.0 ) );
    }
    else
    {
      imageStore( image, ivec2( gl_LaunchIDEXT.xy ), vec4( prd.hitValue, 1.0 ) );
    }
  }
  // No anti aliasing
  else
  {
    vec2 positionWithinPixel = vec2( gl_LaunchIDEXT.xy ) + vec2( 0.5 );
    rayTrace( positionWithinPixel );

    imageStore( image, ivec2( gl_LaunchIDEXT.xy ), vec4( prd.hitValue, 1.0 ) );
  }
}
