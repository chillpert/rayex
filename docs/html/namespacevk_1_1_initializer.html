<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RAYEXEC: vk::Initializer Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RAYEXEC
   &#160;<span id="projectnumber">0.5</span>
   </div>
   <div id="projectbrief">A cross-platform Vulkan-based path tracing rendering library.</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacevk_1_1_initializer.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">vk::Initializer Namespace Reference<div class="ingroups"><a class="el" href="group___a_p_i.html">Vulkan</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A collection of functions to initialize or allocate Vulkan resources.  
<a href="namespacevk_1_1_initializer.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae6a5303506418677ec639446ef16cc46"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevk_1_1_initializer.html#ae6a5303506418677ec639446ef16cc46">initFenceUnique</a> (FenceCreateFlags flags=FenceCreateFlagBits::eSignaled) -&gt; UniqueFence</td></tr>
<tr class="memdesc:ae6a5303506418677ec639446ef16cc46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a fence with a unique handle.  <a href="namespacevk_1_1_initializer.html#ae6a5303506418677ec639446ef16cc46">More...</a><br /></td></tr>
<tr class="separator:ae6a5303506418677ec639446ef16cc46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6bf761ce27237bb82fb5e02535617d9"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevk_1_1_initializer.html#af6bf761ce27237bb82fb5e02535617d9">initFence</a> (FenceCreateFlags flags=FenceCreateFlagBits::eSignaled) -&gt; Fence</td></tr>
<tr class="memdesc:af6bf761ce27237bb82fb5e02535617d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a fence.  <a href="namespacevk_1_1_initializer.html#af6bf761ce27237bb82fb5e02535617d9">More...</a><br /></td></tr>
<tr class="separator:af6bf761ce27237bb82fb5e02535617d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a375ed5917667a58eff188349cf3f9050"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevk_1_1_initializer.html#a375ed5917667a58eff188349cf3f9050">initSemaphoreUnique</a> (SemaphoreCreateFlags flags={ }) -&gt; UniqueSemaphore</td></tr>
<tr class="memdesc:a375ed5917667a58eff188349cf3f9050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a semaphore with a unique handle.  <a href="namespacevk_1_1_initializer.html#a375ed5917667a58eff188349cf3f9050">More...</a><br /></td></tr>
<tr class="separator:a375ed5917667a58eff188349cf3f9050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ec2f4e793ae3383e4c69db03ff4fc1"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevk_1_1_initializer.html#ac1ec2f4e793ae3383e4c69db03ff4fc1">initSemaphore</a> (SemaphoreCreateFlags flags={ }) -&gt; Semaphore</td></tr>
<tr class="memdesc:ac1ec2f4e793ae3383e4c69db03ff4fc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a semaphore.  <a href="namespacevk_1_1_initializer.html#ac1ec2f4e793ae3383e4c69db03ff4fc1">More...</a><br /></td></tr>
<tr class="separator:ac1ec2f4e793ae3383e4c69db03ff4fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acef14128475ec3fe6c547ff6673fd23a"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevk_1_1_initializer.html#acef14128475ec3fe6c547ff6673fd23a">initCommandPoolUnique</a> (uint32_t queueFamilyIndex, CommandPoolCreateFlags flags={ }) -&gt; UniqueCommandPool</td></tr>
<tr class="memdesc:acef14128475ec3fe6c547ff6673fd23a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a command pool with a unique handle.  <a href="namespacevk_1_1_initializer.html#acef14128475ec3fe6c547ff6673fd23a">More...</a><br /></td></tr>
<tr class="separator:acef14128475ec3fe6c547ff6673fd23a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f31060460247e2cec9de6164b6e0057"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevk_1_1_initializer.html#a4f31060460247e2cec9de6164b6e0057">initCommandPool</a> (uint32_t queueFamilyIndex, CommandPoolCreateFlags flags={ }) -&gt; CommandPool</td></tr>
<tr class="memdesc:a4f31060460247e2cec9de6164b6e0057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a command pool.  <a href="namespacevk_1_1_initializer.html#a4f31060460247e2cec9de6164b6e0057">More...</a><br /></td></tr>
<tr class="separator:a4f31060460247e2cec9de6164b6e0057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdbf982d7f7d6c943c5d7698640eeb28"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevk_1_1_initializer.html#acdbf982d7f7d6c943c5d7698640eeb28">initDescriptorPoolUnique</a> (const std::vector&lt; DescriptorPoolSize &gt; &amp;poolSizes, uint32_t maxSets=1, DescriptorPoolCreateFlags flags={ }) -&gt; UniqueDescriptorPool</td></tr>
<tr class="memdesc:acdbf982d7f7d6c943c5d7698640eeb28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a unique descriptor pool.  <a href="namespacevk_1_1_initializer.html#acdbf982d7f7d6c943c5d7698640eeb28">More...</a><br /></td></tr>
<tr class="separator:acdbf982d7f7d6c943c5d7698640eeb28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed58fa91ff66a059c1a2aba841c62094"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevk_1_1_initializer.html#aed58fa91ff66a059c1a2aba841c62094">initDescriptorSetsUnique</a> (const UniqueDescriptorPool &amp;pool, const UniqueDescriptorSetLayout &amp;layout) -&gt; std::vector&lt; DescriptorSet &gt;</td></tr>
<tr class="memdesc:aed58fa91ff66a059c1a2aba841c62094"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates unique Vulkan descriptor sets.  <a href="namespacevk_1_1_initializer.html#aed58fa91ff66a059c1a2aba841c62094">More...</a><br /></td></tr>
<tr class="separator:aed58fa91ff66a059c1a2aba841c62094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a493d221cb9855740252a5e69a8ca0838"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevk_1_1_initializer.html#a493d221cb9855740252a5e69a8ca0838">allocateMemoryUnique</a> (Image image, MemoryPropertyFlags propertyFlags=MemoryPropertyFlagBits::eDeviceLocal, void *pNext=nullptr) -&gt; UniqueDeviceMemory</td></tr>
<tr class="memdesc:a493d221cb9855740252a5e69a8ca0838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates and binds unique memory for an image.  <a href="namespacevk_1_1_initializer.html#a493d221cb9855740252a5e69a8ca0838">More...</a><br /></td></tr>
<tr class="separator:a493d221cb9855740252a5e69a8ca0838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af484445cf6e33bde051680745478e92e"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevk_1_1_initializer.html#af484445cf6e33bde051680745478e92e">allocateMemory</a> (Image image, MemoryPropertyFlags propertyFlags=MemoryPropertyFlagBits::eDeviceLocal, void *pNext=nullptr) -&gt; DeviceMemory</td></tr>
<tr class="memdesc:af484445cf6e33bde051680745478e92e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates and binds memory for an image.  <a href="namespacevk_1_1_initializer.html#af484445cf6e33bde051680745478e92e">More...</a><br /></td></tr>
<tr class="separator:af484445cf6e33bde051680745478e92e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12c5bd8256a38e454966161b5742d75d"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevk_1_1_initializer.html#a12c5bd8256a38e454966161b5742d75d">allocateMemoryUnique</a> (Buffer buffer, MemoryPropertyFlags propertyFlags=MemoryPropertyFlagBits::eDeviceLocal, void *pNext=nullptr) -&gt; UniqueDeviceMemory</td></tr>
<tr class="memdesc:a12c5bd8256a38e454966161b5742d75d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates and binds unique memory for a buffer.  <a href="namespacevk_1_1_initializer.html#a12c5bd8256a38e454966161b5742d75d">More...</a><br /></td></tr>
<tr class="separator:a12c5bd8256a38e454966161b5742d75d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af77161879bc78a43e42f1df9f35b8f42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevk_1_1_initializer.html#af77161879bc78a43e42f1df9f35b8f42">allocateMemory</a> (<a class="el" href="struct_r_a_y_e_x_e_c___n_a_m_e_s_p_a_c_e_1_1_acceleration_structure.html">RAYEXEC_NAMESPACE::AccelerationStructure</a> &amp;as)</td></tr>
<tr class="memdesc:af77161879bc78a43e42f1df9f35b8f42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates and binds unique memory for an acceleration structure object.  <a href="namespacevk_1_1_initializer.html#af77161879bc78a43e42f1df9f35b8f42">More...</a><br /></td></tr>
<tr class="separator:af77161879bc78a43e42f1df9f35b8f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf85382b3d1c452170cae8ebc6aa0b7d"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevk_1_1_initializer.html#acf85382b3d1c452170cae8ebc6aa0b7d">allocateMemory</a> (Buffer buffer, MemoryPropertyFlags propertyFlags=MemoryPropertyFlagBits::eDeviceLocal, void *pNext=nullptr) -&gt; DeviceMemory</td></tr>
<tr class="memdesc:acf85382b3d1c452170cae8ebc6aa0b7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates and binds memory for a buffer.  <a href="namespacevk_1_1_initializer.html#acf85382b3d1c452170cae8ebc6aa0b7d">More...</a><br /></td></tr>
<tr class="separator:acf85382b3d1c452170cae8ebc6aa0b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6858c4358b2619eb467a19914ed2e49a"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevk_1_1_initializer.html#a6858c4358b2619eb467a19914ed2e49a">initImageViewUnique</a> (Image image, Format format, ImageAspectFlags aspectFlags=ImageAspectFlagBits::eColor) -&gt; UniqueImageView</td></tr>
<tr class="memdesc:a6858c4358b2619eb467a19914ed2e49a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an image view with a unique handle.  <a href="namespacevk_1_1_initializer.html#a6858c4358b2619eb467a19914ed2e49a">More...</a><br /></td></tr>
<tr class="separator:a6858c4358b2619eb467a19914ed2e49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6969775adbf212f8403a88b86d6c3ad3"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevk_1_1_initializer.html#a6969775adbf212f8403a88b86d6c3ad3">initImageView</a> (Image image, Format format, ImageAspectFlags aspectFlags=ImageAspectFlagBits::eColor) -&gt; ImageView</td></tr>
<tr class="memdesc:a6969775adbf212f8403a88b86d6c3ad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an image view.  <a href="namespacevk_1_1_initializer.html#a6969775adbf212f8403a88b86d6c3ad3">More...</a><br /></td></tr>
<tr class="separator:a6969775adbf212f8403a88b86d6c3ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36373e7db0323614fb7a613a25034b88"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevk_1_1_initializer.html#a36373e7db0323614fb7a613a25034b88">initSamplerUnique</a> (const SamplerCreateInfo &amp;createInfo) -&gt; UniqueSampler</td></tr>
<tr class="memdesc:a36373e7db0323614fb7a613a25034b88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a sampler with a unique handle.  <a href="namespacevk_1_1_initializer.html#a36373e7db0323614fb7a613a25034b88">More...</a><br /></td></tr>
<tr class="separator:a36373e7db0323614fb7a613a25034b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f3e62260a13de38ef88a420ba60728"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevk_1_1_initializer.html#a12f3e62260a13de38ef88a420ba60728">initSampler</a> (const SamplerCreateInfo &amp;createInfo) -&gt; Sampler</td></tr>
<tr class="memdesc:a12f3e62260a13de38ef88a420ba60728"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a sampler.  <a href="namespacevk_1_1_initializer.html#a12f3e62260a13de38ef88a420ba60728">More...</a><br /></td></tr>
<tr class="separator:a12f3e62260a13de38ef88a420ba60728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e3b424e471133a3a1108d239ad3b0d5"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevk_1_1_initializer.html#a9e3b424e471133a3a1108d239ad3b0d5">initFramebufferUnique</a> (const std::vector&lt; ImageView &gt; &amp;attachments, RenderPass renderPass, const Extent2D &amp;extent) -&gt; UniqueFramebuffer</td></tr>
<tr class="memdesc:a9e3b424e471133a3a1108d239ad3b0d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a framebuffer with a unique handle.  <a href="namespacevk_1_1_initializer.html#a9e3b424e471133a3a1108d239ad3b0d5">More...</a><br /></td></tr>
<tr class="separator:a9e3b424e471133a3a1108d239ad3b0d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a203917e1ea8b661b32363a2498d3fb"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevk_1_1_initializer.html#a8a203917e1ea8b661b32363a2498d3fb">initFramebuffer</a> (const std::vector&lt; ImageView &gt; &amp;attachments, RenderPass renderPass, const Extent2D &amp;extent) -&gt; Framebuffer</td></tr>
<tr class="memdesc:a8a203917e1ea8b661b32363a2498d3fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a framebuffer.  <a href="namespacevk_1_1_initializer.html#a8a203917e1ea8b661b32363a2498d3fb">More...</a><br /></td></tr>
<tr class="separator:a8a203917e1ea8b661b32363a2498d3fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79c8c72a6ff7bfe8023ea424950b537c"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevk_1_1_initializer.html#a79c8c72a6ff7bfe8023ea424950b537c">initQueryPoolUnique</a> (uint32_t count, QueryType type) -&gt; UniqueQueryPool</td></tr>
<tr class="memdesc:a79c8c72a6ff7bfe8023ea424950b537c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a query pool with a unique handle.  <a href="namespacevk_1_1_initializer.html#a79c8c72a6ff7bfe8023ea424950b537c">More...</a><br /></td></tr>
<tr class="separator:a79c8c72a6ff7bfe8023ea424950b537c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a948d9f0a9db128c05db21a601e5d3edb"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevk_1_1_initializer.html#a948d9f0a9db128c05db21a601e5d3edb">initQueryPool</a> (uint32_t count, QueryType type) -&gt; QueryPool</td></tr>
<tr class="memdesc:a948d9f0a9db128c05db21a601e5d3edb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a query pool.  <a href="namespacevk_1_1_initializer.html#a948d9f0a9db128c05db21a601e5d3edb">More...</a><br /></td></tr>
<tr class="separator:a948d9f0a9db128c05db21a601e5d3edb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5138790657c39af09df37198eb9fbb7"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevk_1_1_initializer.html#ac5138790657c39af09df37198eb9fbb7">initShaderModuleUnique</a> (std::string_view path) -&gt; UniqueShaderModule</td></tr>
<tr class="memdesc:ac5138790657c39af09df37198eb9fbb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a given shader and inits a shader module with a unique handle.  <a href="namespacevk_1_1_initializer.html#ac5138790657c39af09df37198eb9fbb7">More...</a><br /></td></tr>
<tr class="separator:ac5138790657c39af09df37198eb9fbb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ea60eaa2fc1b0d0dce038f5d6b3720a"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevk_1_1_initializer.html#a5ea60eaa2fc1b0d0dce038f5d6b3720a">initShaderModule</a> (std::string_view path) -&gt; ShaderModule</td></tr>
<tr class="memdesc:a5ea60eaa2fc1b0d0dce038f5d6b3720a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a given shader and inits a shader module.  <a href="namespacevk_1_1_initializer.html#a5ea60eaa2fc1b0d0dce038f5d6b3720a">More...</a><br /></td></tr>
<tr class="separator:a5ea60eaa2fc1b0d0dce038f5d6b3720a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9059624057ddeeab8a7a1ffe403b6bd"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevk_1_1_initializer.html#ae9059624057ddeeab8a7a1ffe403b6bd">initAccelerationStructure</a> (const AccelerationStructureCreateInfoKHR &amp;asCreateInfo) -&gt; <a class="el" href="struct_r_a_y_e_x_e_c___n_a_m_e_s_p_a_c_e_1_1_acceleration_structure.html">RAYEXEC_NAMESPACE::AccelerationStructure</a></td></tr>
<tr class="memdesc:ae9059624057ddeeab8a7a1ffe403b6bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the acceleration structure and allocates and binds memory for it.  <a href="namespacevk_1_1_initializer.html#ae9059624057ddeeab8a7a1ffe403b6bd">More...</a><br /></td></tr>
<tr class="separator:ae9059624057ddeeab8a7a1ffe403b6bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa312efed5e4aa5e591b86a2759248d55"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevk_1_1_initializer.html#aa312efed5e4aa5e591b86a2759248d55">initPhysicalDevice</a> () -&gt; PhysicalDevice</td></tr>
<tr class="memdesc:aa312efed5e4aa5e591b86a2759248d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the most suited GPU on the current machine.  <a href="namespacevk_1_1_initializer.html#aa312efed5e4aa5e591b86a2759248d55">More...</a><br /></td></tr>
<tr class="separator:aa312efed5e4aa5e591b86a2759248d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41bd7737bda712ebcd0c6a66d336e4ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevk_1_1_initializer.html#a41bd7737bda712ebcd0c6a66d336e4ab">initQueueFamilyIndices</a> ()</td></tr>
<tr class="memdesc:a41bd7737bda712ebcd0c6a66d336e4ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the queue family indices for both graphics and transfer queue families.  <a href="namespacevk_1_1_initializer.html#a41bd7737bda712ebcd0c6a66d336e4ab">More...</a><br /></td></tr>
<tr class="separator:a41bd7737bda712ebcd0c6a66d336e4ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a162632da0a356f8cc311c6c0290cfff1"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevk_1_1_initializer.html#a162632da0a356f8cc311c6c0290cfff1">initDevice</a> (std::vector&lt; const char * &gt; &amp;extensions) -&gt; UniqueDevice</td></tr>
<tr class="memdesc:a162632da0a356f8cc311c6c0290cfff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the logical device and enables all device extensions provided if they are supported.  <a href="namespacevk_1_1_initializer.html#a162632da0a356f8cc311c6c0290cfff1">More...</a><br /></td></tr>
<tr class="separator:a162632da0a356f8cc311c6c0290cfff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a837538230a0f3327ba32f5803e174c62"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevk_1_1_initializer.html#a837538230a0f3327ba32f5803e174c62">initInstance</a> (const std::vector&lt; const char * &gt; &amp;layers, std::vector&lt; const char * &gt; &amp;extensions) -&gt; UniqueInstance</td></tr>
<tr class="memdesc:a837538230a0f3327ba32f5803e174c62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the instance object and checks support for any given layer and extension.  <a href="namespacevk_1_1_initializer.html#a837538230a0f3327ba32f5803e174c62">More...</a><br /></td></tr>
<tr class="separator:a837538230a0f3327ba32f5803e174c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A collection of functions to initialize or allocate Vulkan resources. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="acf85382b3d1c452170cae8ebc6aa0b7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf85382b3d1c452170cae8ebc6aa0b7d">&#9670;&nbsp;</a></span>allocateMemory() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vk::Initializer::allocateMemory </td>
          <td>(</td>
          <td class="paramtype">Buffer&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MemoryPropertyFlags&#160;</td>
          <td class="paramname"><em>propertyFlags</em> = <code>MemoryPropertyFlagBits::eDeviceLocal</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pNext</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  DeviceMemory</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates and binds memory for a buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to allocate memory for. </td></tr>
    <tr><td class="paramname">propertyFlags</td><td>The memory property flags. </td></tr>
    <tr><td class="paramname">pNext</td><td>The pNext chain of the Vulkan allocation info. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the memory. </dd></dl>

</div>
</div>
<a id="af484445cf6e33bde051680745478e92e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af484445cf6e33bde051680745478e92e">&#9670;&nbsp;</a></span>allocateMemory() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vk::Initializer::allocateMemory </td>
          <td>(</td>
          <td class="paramtype">Image&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MemoryPropertyFlags&#160;</td>
          <td class="paramname"><em>propertyFlags</em> = <code>MemoryPropertyFlagBits::eDeviceLocal</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pNext</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  DeviceMemory</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates and binds memory for an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>The image to allocate memory for. </td></tr>
    <tr><td class="paramname">propertyFlags</td><td>The memory property flags. </td></tr>
    <tr><td class="paramname">pNext</td><td>The pNext chain of the Vulkan allocation info. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the memory. </dd></dl>

</div>
</div>
<a id="af77161879bc78a43e42f1df9f35b8f42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af77161879bc78a43e42f1df9f35b8f42">&#9670;&nbsp;</a></span>allocateMemory() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vk::Initializer::allocateMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_r_a_y_e_x_e_c___n_a_m_e_s_p_a_c_e_1_1_acceleration_structure.html">RAYEXEC_NAMESPACE::AccelerationStructure</a> &amp;&#160;</td>
          <td class="paramname"><em>as</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates and binds unique memory for an acceleration structure object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">as</td><td>The <a class="el" href="struct_r_a_y_e_x_e_c___n_a_m_e_s_p_a_c_e_1_1_acceleration_structure.html" title="A wrapper for a Vulkan acceleration Structure.">RAYEXEC_NAMESPACE::AccelerationStructure</a> object the memory will be allocated for. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a12c5bd8256a38e454966161b5742d75d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12c5bd8256a38e454966161b5742d75d">&#9670;&nbsp;</a></span>allocateMemoryUnique() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vk::Initializer::allocateMemoryUnique </td>
          <td>(</td>
          <td class="paramtype">Buffer&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MemoryPropertyFlags&#160;</td>
          <td class="paramname"><em>propertyFlags</em> = <code>MemoryPropertyFlagBits::eDeviceLocal</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pNext</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  UniqueDeviceMemory</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates and binds unique memory for a buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to allocate memory for. </td></tr>
    <tr><td class="paramname">propertyFlags</td><td>The memory property flags. </td></tr>
    <tr><td class="paramname">pNext</td><td>The pNext chain of the Vulkan allocation info. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the memory. </dd></dl>

</div>
</div>
<a id="a493d221cb9855740252a5e69a8ca0838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a493d221cb9855740252a5e69a8ca0838">&#9670;&nbsp;</a></span>allocateMemoryUnique() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vk::Initializer::allocateMemoryUnique </td>
          <td>(</td>
          <td class="paramtype">Image&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MemoryPropertyFlags&#160;</td>
          <td class="paramname"><em>propertyFlags</em> = <code>MemoryPropertyFlagBits::eDeviceLocal</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pNext</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  UniqueDeviceMemory</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates and binds unique memory for an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>The image to allocate memory for. </td></tr>
    <tr><td class="paramname">propertyFlags</td><td>The memory property flags. </td></tr>
    <tr><td class="paramname">pNext</td><td>The pNext chain of the Vulkan allocation info. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the memory. </dd></dl>

</div>
</div>
<a id="ae9059624057ddeeab8a7a1ffe403b6bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9059624057ddeeab8a7a1ffe403b6bd">&#9670;&nbsp;</a></span>initAccelerationStructure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vk::Initializer::initAccelerationStructure </td>
          <td>(</td>
          <td class="paramtype">const AccelerationStructureCreateInfoKHR &amp;&#160;</td>
          <td class="paramname"><em>asCreateInfo</em></td><td>)</td>
          <td> -&gt;  <a class="el" href="struct_r_a_y_e_x_e_c___n_a_m_e_s_p_a_c_e_1_1_acceleration_structure.html">RAYEXEC_NAMESPACE::AccelerationStructure</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates the acceleration structure and allocates and binds memory for it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">asCreateInfo</td><td>The Vulkan init info for the acceleration structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an <a class="el" href="struct_r_a_y_e_x_e_c___n_a_m_e_s_p_a_c_e_1_1_acceleration_structure.html" title="A wrapper for a Vulkan acceleration Structure.">RAYEXEC_NAMESPACE::AccelerationStructure</a> object that contains the AS itself as well as the memory for it. </dd></dl>

</div>
</div>
<a id="a4f31060460247e2cec9de6164b6e0057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f31060460247e2cec9de6164b6e0057">&#9670;&nbsp;</a></span>initCommandPool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vk::Initializer::initCommandPool </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>queueFamilyIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CommandPoolCreateFlags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>{&#160;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  CommandPool</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a command pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queueFamilyIndex</td><td>The queue family from which the command pool can submit to. </td></tr>
    <tr><td class="paramname">flags</td><td>The flags used for creating the command pool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the command pool. </dd></dl>

</div>
</div>
<a id="acef14128475ec3fe6c547ff6673fd23a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acef14128475ec3fe6c547ff6673fd23a">&#9670;&nbsp;</a></span>initCommandPoolUnique()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vk::Initializer::initCommandPoolUnique </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>queueFamilyIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CommandPoolCreateFlags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>{&#160;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  UniqueCommandPool</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a command pool with a unique handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queueFamilyIndex</td><td>The queue family from which the command pool can submit to. </td></tr>
    <tr><td class="paramname">flags</td><td>The flags used for creating the command pool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the command pool. </dd></dl>

</div>
</div>
<a id="acdbf982d7f7d6c943c5d7698640eeb28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdbf982d7f7d6c943c5d7698640eeb28">&#9670;&nbsp;</a></span>initDescriptorPoolUnique()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vk::Initializer::initDescriptorPoolUnique </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; DescriptorPoolSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>poolSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>maxSets</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DescriptorPoolCreateFlags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>{&#160;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  UniqueDescriptorPool</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a unique descriptor pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poolSizes</td><td>A vector of Vulkan descriptor pool sizes. </td></tr>
    <tr><td class="paramname">maxSets</td><td>The maximum amount of descriptor sets that can be allocated from this pool. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags for the creation process. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed58fa91ff66a059c1a2aba841c62094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed58fa91ff66a059c1a2aba841c62094">&#9670;&nbsp;</a></span>initDescriptorSetsUnique()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vk::Initializer::initDescriptorSetsUnique </td>
          <td>(</td>
          <td class="paramtype">const UniqueDescriptorPool &amp;&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UniqueDescriptorSetLayout &amp;&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  std::vector&lt; DescriptorSet &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates unique Vulkan descriptor sets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>A unique Vulkan descriptor pool to allocate the sets from. </td></tr>
    <tr><td class="paramname">layout</td><td>The desired unique Vulkan descriptor set layout. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a162632da0a356f8cc311c6c0290cfff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a162632da0a356f8cc311c6c0290cfff1">&#9670;&nbsp;</a></span>initDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vk::Initializer::initDevice </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; const char * &gt; &amp;&#160;</td>
          <td class="paramname"><em>extensions</em></td><td>)</td>
          <td> -&gt;  UniqueDevice</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates the logical device and enables all device extensions provided if they are supported. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extensions</td><td>All device extensions that should be enabled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the initilization was successful. </dd></dl>

</div>
</div>
<a id="af6bf761ce27237bb82fb5e02535617d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6bf761ce27237bb82fb5e02535617d9">&#9670;&nbsp;</a></span>initFence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vk::Initializer::initFence </td>
          <td>(</td>
          <td class="paramtype">FenceCreateFlags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>FenceCreateFlagBits::eSignaled</code></td><td>)</td>
          <td> -&gt;  Fence</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a fence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>The flags used for creating the fence. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the fence. </dd></dl>

</div>
</div>
<a id="ae6a5303506418677ec639446ef16cc46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6a5303506418677ec639446ef16cc46">&#9670;&nbsp;</a></span>initFenceUnique()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vk::Initializer::initFenceUnique </td>
          <td>(</td>
          <td class="paramtype">FenceCreateFlags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>FenceCreateFlagBits::eSignaled</code></td><td>)</td>
          <td> -&gt;  UniqueFence</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a fence with a unique handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>The flags used for creating the fence. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the fence. </dd></dl>

</div>
</div>
<a id="a8a203917e1ea8b661b32363a2498d3fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a203917e1ea8b661b32363a2498d3fb">&#9670;&nbsp;</a></span>initFramebuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vk::Initializer::initFramebuffer </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; ImageView &gt; &amp;&#160;</td>
          <td class="paramname"><em>attachments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RenderPass&#160;</td>
          <td class="paramname"><em>renderPass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Extent2D &amp;&#160;</td>
          <td class="paramname"><em>extent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  Framebuffer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a framebuffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attachments</td><td>All the image view attachments for the framebuffer. </td></tr>
    <tr><td class="paramname">renderPass</td><td>The render pass for which the framebuffer will be used. </td></tr>
    <tr><td class="paramname">extent</td><td>The extent of the framebuffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the framebuffer. </dd></dl>

</div>
</div>
<a id="a9e3b424e471133a3a1108d239ad3b0d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e3b424e471133a3a1108d239ad3b0d5">&#9670;&nbsp;</a></span>initFramebufferUnique()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vk::Initializer::initFramebufferUnique </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; ImageView &gt; &amp;&#160;</td>
          <td class="paramname"><em>attachments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RenderPass&#160;</td>
          <td class="paramname"><em>renderPass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Extent2D &amp;&#160;</td>
          <td class="paramname"><em>extent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  UniqueFramebuffer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a framebuffer with a unique handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attachments</td><td>All the image view attachments for the framebuffer. </td></tr>
    <tr><td class="paramname">renderPass</td><td>The render pass for which the framebuffer will be used. </td></tr>
    <tr><td class="paramname">extent</td><td>The extent of the framebuffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the framebuffer. </dd></dl>

</div>
</div>
<a id="a6969775adbf212f8403a88b86d6c3ad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6969775adbf212f8403a88b86d6c3ad3">&#9670;&nbsp;</a></span>initImageView()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vk::Initializer::initImageView </td>
          <td>(</td>
          <td class="paramtype">Image&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Format&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ImageAspectFlags&#160;</td>
          <td class="paramname"><em>aspectFlags</em> = <code>ImageAspectFlagBits::eColor</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  ImageView</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an image view. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>The image to init an image view for. </td></tr>
    <tr><td class="paramname">aspectFlags</td><td>The image's aspect flags. </td></tr>
    <tr><td class="paramname">format</td><td>The target format of the image view. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the image view. </dd></dl>

</div>
</div>
<a id="a6858c4358b2619eb467a19914ed2e49a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6858c4358b2619eb467a19914ed2e49a">&#9670;&nbsp;</a></span>initImageViewUnique()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vk::Initializer::initImageViewUnique </td>
          <td>(</td>
          <td class="paramtype">Image&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Format&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ImageAspectFlags&#160;</td>
          <td class="paramname"><em>aspectFlags</em> = <code>ImageAspectFlagBits::eColor</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  UniqueImageView</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an image view with a unique handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>The image to init an image view for. </td></tr>
    <tr><td class="paramname">aspectFlags</td><td>The image's aspect flags. </td></tr>
    <tr><td class="paramname">format</td><td>The target format of the image view. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the image view. </dd></dl>

</div>
</div>
<a id="a837538230a0f3327ba32f5803e174c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a837538230a0f3327ba32f5803e174c62">&#9670;&nbsp;</a></span>initInstance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vk::Initializer::initInstance </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const char * &gt; &amp;&#160;</td>
          <td class="paramname"><em>layers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; const char * &gt; &amp;&#160;</td>
          <td class="paramname"><em>extensions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  UniqueInstance</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the instance object and checks support for any given layer and extension. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layers</td><td>All validation layers that should be activated. </td></tr>
    <tr><td class="paramname">extensions</td><td>All instance extensions that should be activated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The given vector with the extensions will be appended by ones that are required by the window. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if initialization was successful. </dd></dl>

</div>
</div>
<a id="aa312efed5e4aa5e591b86a2759248d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa312efed5e4aa5e591b86a2759248d55">&#9670;&nbsp;</a></span>initPhysicalDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vk::Initializer::initPhysicalDevice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  PhysicalDevice</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the most suited GPU on the current machine. </p>
<p>If a device is found its properties and features will be retrieved. </p><dl class="section return"><dt>Returns</dt><dd>Returns true if the initilization was successful. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Multiple GPUs can not be utilized. </dd></dl>

</div>
</div>
<a id="a948d9f0a9db128c05db21a601e5d3edb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a948d9f0a9db128c05db21a601e5d3edb">&#9670;&nbsp;</a></span>initQueryPool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vk::Initializer::initQueryPool </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QueryType&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  QueryPool</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a query pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The number of queries managed by the pool. </td></tr>
    <tr><td class="paramname">type</td><td>Specifies the type of queries managed by the pool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the query pool. </dd></dl>

</div>
</div>
<a id="a79c8c72a6ff7bfe8023ea424950b537c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79c8c72a6ff7bfe8023ea424950b537c">&#9670;&nbsp;</a></span>initQueryPoolUnique()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vk::Initializer::initQueryPoolUnique </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QueryType&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  UniqueQueryPool</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a query pool with a unique handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The number of queries managed by the pool. </td></tr>
    <tr><td class="paramname">type</td><td>Specifies the type of queries managed by the pool. return Returns the query pool. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a41bd7737bda712ebcd0c6a66d336e4ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41bd7737bda712ebcd0c6a66d336e4ab">&#9670;&nbsp;</a></span>initQueueFamilyIndices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vk::Initializer::initQueueFamilyIndices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the queue family indices for both graphics and transfer queue families. </p>
<dl class="section note"><dt>Note</dt><dd>The function tries to find a transfer queue family index that is not the same as the graphics queue family index. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>hasDedicatedTransferQueueFamily(vk::PhysicalDevice) </dd></dl>

</div>
</div>
<a id="a12f3e62260a13de38ef88a420ba60728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12f3e62260a13de38ef88a420ba60728">&#9670;&nbsp;</a></span>initSampler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vk::Initializer::initSampler </td>
          <td>(</td>
          <td class="paramtype">const SamplerCreateInfo &amp;&#160;</td>
          <td class="paramname"><em>createInfo</em></td><td>)</td>
          <td> -&gt;  Sampler</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a sampler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">createInfo</td><td>The Vulkan init info for the sampler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the sampler. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use RAYEXEC_NAMESPACE::Helper::getSamplerCreateInfo to get a predefined init info. </dd></dl>

</div>
</div>
<a id="a36373e7db0323614fb7a613a25034b88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36373e7db0323614fb7a613a25034b88">&#9670;&nbsp;</a></span>initSamplerUnique()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vk::Initializer::initSamplerUnique </td>
          <td>(</td>
          <td class="paramtype">const SamplerCreateInfo &amp;&#160;</td>
          <td class="paramname"><em>createInfo</em></td><td>)</td>
          <td> -&gt;  UniqueSampler</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a sampler with a unique handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">createInfo</td><td>The Vulkan init info for the sampler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the sampler. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use RAYEXEC_NAMESPACE::Helper::getSamplerCreateInfo to get a predefined init info. </dd></dl>

</div>
</div>
<a id="ac1ec2f4e793ae3383e4c69db03ff4fc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1ec2f4e793ae3383e4c69db03ff4fc1">&#9670;&nbsp;</a></span>initSemaphore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vk::Initializer::initSemaphore </td>
          <td>(</td>
          <td class="paramtype">SemaphoreCreateFlags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>{&#160;}</code></td><td>)</td>
          <td> -&gt;  Semaphore</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a semaphore. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>The flags used for creating the semaphore. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the semaphore. </dd></dl>

</div>
</div>
<a id="a375ed5917667a58eff188349cf3f9050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a375ed5917667a58eff188349cf3f9050">&#9670;&nbsp;</a></span>initSemaphoreUnique()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vk::Initializer::initSemaphoreUnique </td>
          <td>(</td>
          <td class="paramtype">SemaphoreCreateFlags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>{&#160;}</code></td><td>)</td>
          <td> -&gt;  UniqueSemaphore</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a semaphore with a unique handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>The flags used for creating the semaphore. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the semaphore. </dd></dl>

</div>
</div>
<a id="a5ea60eaa2fc1b0d0dce038f5d6b3720a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ea60eaa2fc1b0d0dce038f5d6b3720a">&#9670;&nbsp;</a></span>initShaderModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vk::Initializer::initShaderModule </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td> -&gt;  ShaderModule</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a given shader and inits a shader module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The full path to the GLSL shader file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the shader module. </dd></dl>

</div>
</div>
<a id="ac5138790657c39af09df37198eb9fbb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5138790657c39af09df37198eb9fbb7">&#9670;&nbsp;</a></span>initShaderModuleUnique()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vk::Initializer::initShaderModuleUnique </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td> -&gt;  UniqueShaderModule</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a given shader and inits a shader module with a unique handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The full path to the GLSL shader file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the shader module. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacevk.html">vk</a></li><li class="navelem"><a class="el" href="namespacevk_1_1_initializer.html">Initializer</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
